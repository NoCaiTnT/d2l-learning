# 贪心搜索
#   在seq2seq中我们使用了贪心搜索来预测序列
#       将当前时刻预测概率最大的词作为输出
#   但是贪心搜索可能并不是最优解(当前最优不一定是全局最优, 上一个选择可能会影响下一个选择)
#       即: 步步最优不一定是全局最优

# 穷举搜索
#   最优算法: 对所有可能的序列, 计算它的概率, 然后选取最好的那个
#   如果输出字典大小为n, 序列长度为T, 那么复杂度为O(n^T)
#       n = 10000, T = 10, 复杂度为10^40, 不可行

# 可以使用元启发式吗?
# 束搜索beam search
#   保存最好的k个候选
#   在每个时刻, 对每个候选新加一项(n种可能), 在kn个选项中选出最好的k个
#   即: 在每个时间步, 选择最好的k个序列, 对这k个序列分别预测下一个词, 再从中选择最好的k个序列
#   时间复杂度为O(knT)
#       k = 5, n = 10000, T = 10, 复杂度为5*10000*10 = 500000
#   每个候选的最终分数是:
#       1/(L^α) log p(y1,...,yL) = 1/(L^α) ∑_{t'=1}^{L} log p(y_t'|y1,...,y_{t'-1})
#       通常α=0.75 (L是序列长度, α是一个超参数) 使得长序列有优势

# 总结
#   束搜索在每次搜索时保存k个最好的候选
#   k = 1时就是贪心搜索
#   k = n 不是穷举
#   k越大, 结果越好, 但是计算量也越大